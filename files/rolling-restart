#!/usr/bin/env python3
# Mgrep rolling restart controller
#
# Runs as a cron job to restart mgrep daemons on two nodes when the dictionary file is updated.
#
# Logic:
# 1. The master node detects an updated dictionary (based on Redis timestamps).
# 2. The master waits for the slave node to restart first.
# 3. The slave notifies the master via Redis Pub/Sub when its restart is complete.
# 4. The master restarts mgrep and updates the restart timestamp in Redis.
#
# Author: Alex Skrenchuk

import argparse
import os
import socket
import sys
import time
import uuid
from datetime import datetime
from subprocess import run

import redis
from redis.exceptions import ConnectionError, TimeoutError, RedisError

HOSTNAME = socket.gethostname()

# Redis keys
K_LAST_RESTART = "last_mgrep_restart_stamp"     # written by this script (epoch)
K_DICT_REFRESH = "mgrep_dict_refresh_stamp"     # written by Ruby process

PUBSUB_CHANNEL = "mgrep_restart-channel"
LOCK_KEY = "mgrep_restart_lock"
RUN_KEY_FMT = "mgrep_restart_runlock:{host}"

UNLOCK_LUA = """
if redis.call('GET', KEYS[1]) == ARGV[1] then
  return redis.call('DEL', KEYS[1])
else
  return 0
end
"""

def log(msg, verbose):
    if verbose:
        ts = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        print(f"{ts} [{HOSTNAME}] {msg}")

def parse_ts(val) -> int:
    """Accept epoch or Ruby-style 'YYYY-MM-DD HH:MM:SS -0700' timestamps."""
    if val is None:
        raise ValueError("missing timestamp")
    if isinstance(val, bytes):
        val = val.decode("utf-8", errors="strict")
    s = str(val).strip()

    try:
        return int(float(s))  # epoch
    except (ValueError, TypeError):
        pass

    try:
        dt = datetime.strptime(s, "%Y-%m-%d %H:%M:%S %z")
        return int(dt.timestamp())
    except ValueError:
        raise ValueError(f"unsupported timestamp format: {s!r}")

def redis_time_seconds(r: redis.Redis) -> int:
    secs, _ = r.time()
    return int(secs)

def acquire_lock(r, key, token, ttl, verbose) -> bool:
    ok = r.set(key, token, nx=True, ex=ttl)
    if ok:
        log("acquired lock", verbose)
    return bool(ok)

def safe_release_lock(r, key, token, verbose):
    try:
        r.eval(UNLOCK_LUA, 1, key, token)
        log("released lock", verbose)
    except RedisError:
        log("lock release failed (TTL will clear it)", verbose)

def ensure_single_run_per_host(r, ttl, verbose):
    run_key = RUN_KEY_FMT.format(host=HOSTNAME)
    if not r.set(run_key, "1", nx=True, ex=ttl):
        raise SystemExit("another instance appears to be running on this host")
    return run_key

def delete_key_quiet(r, key):
    try:
        r.delete(key)
    except RedisError:
        pass

def main():
    ap = argparse.ArgumentParser(description="Mgrep rolling restart controller")
    ap.add_argument("-r", "--redis-host", default="localhost")
    ap.add_argument("-p", "--redis-port", type=int, default=6379)
    ap.add_argument("-v", "--verbose", action="store_true")
    ap.add_argument("-f", "--force", action="store_true", help="force restart regardless of timestamps")
    ap.add_argument("-m", "--master", action="store_true", help="master waits for slave restart first")
    ap.add_argument("-s", "--service", default="mgrep.service", help="systemd unit to restart")
    ap.add_argument("--lock-ttl", type=int, default=300)
    ap.add_argument("--run-ttl", type=int, default=600)
    ap.add_argument("--wait-seconds", type=int, default=650)
    args = ap.parse_args()

    r = redis.Redis(host=args.redis_host, port=args.redis_port, decode_responses=True)

    run_key = None
    try:
        run_key = ensure_single_run_per_host(r, ttl=args.run_ttl, verbose=args.verbose)

        try:
            last_raw = r.get(K_LAST_RESTART)
            refresh_raw = r.get(K_DICT_REFRESH)
        except (ConnectionError, TimeoutError) as e:
            raise SystemExit(f"ERROR: Redis unavailable: {e}")

        # --- Decision logic ---
        if args.force:
            log("force flag set; proceeding to restart", args.verbose)
            should_restart = True
        elif refresh_raw is None:
            log("mgrep_dict_refresh_stamp missing; performing initial restart", args.verbose)
            should_restart = True
        elif last_raw is None:
            log("last_mgrep_restart_stamp missing; skipping restart for now", args.verbose)
            return
        else:
            # Parse timestamps
            try:
                last_i = int(last_raw)
            except (ValueError, TypeError):
                last_i = parse_ts(last_raw)
            try:
                refresh_i = parse_ts(refresh_raw)
            except ValueError as e:
                sys.exit(f"ERROR: bad mgrep_dict_refresh_stamp: {e}")

            log(f"{K_LAST_RESTART} = {last_raw}", args.verbose)
            log(f"{K_DICT_REFRESH} = {refresh_raw}", args.verbose)

            should_restart = (last_i < refresh_i)

        if not should_restart:
            log("new dictionary file is NOT detected", args.verbose)
            return

        log("dictionary update detected (or initial/force); preparing to restart", args.verbose)
        # --- Pub/Sub setup ---
        p = r.pubsub(ignore_subscribe_messages=True)
        p.subscribe("mgrep_restart-channel")

        try:
            if args.master:
                deadline = time.monotonic() + args.wait_seconds
                while time.monotonic() < deadline:
                    msg = p.get_message()
                    if msg:
                        log("received slave completion message", args.verbose)
                        break
                    time.sleep(1)
                else:
                    log("no slave message before timeout; proceeding", args.verbose)
            else:
                time.sleep(10)  # give master head start

            token = f"{HOSTNAME}:{os.getpid()}:{uuid.uuid4()}"
            if not acquire_lock(r, LOCK_KEY, token, ttl=args.lock_ttl, verbose=args.verbose):
                log("waiting for lock", args.verbose)
                lock_deadline = time.monotonic() + args.lock_ttl
                while time.monotonic() < lock_deadline:
                    time.sleep(1)
                    if acquire_lock(r, LOCK_KEY, token, ttl=args.lock_ttl, verbose=args.verbose):
                        break
                else:
                    raise SystemExit("ERROR: could not acquire lock")

            try:
                log(f"restarting service {args.service}", args.verbose)
                run(["systemctl", "restart", args.service], check=True, capture_output=True, text=True)
                now_i = redis_time_seconds(r)
                r.set(K_LAST_RESTART, str(now_i))
                time.sleep(10)
                r.publish(PUBSUB_CHANNEL, "done")
                log("restart complete", args.verbose)
            finally:
                safe_release_lock(r, LOCK_KEY, token, args.verbose)
        finally:
            try:
                p.close()
            except Exception:
                pass
    finally:
        if run_key:
            delete_key_quiet(r, run_key)

if __name__ == "__main__":
    main()
